<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Stream</title>
</head>
<body>
    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const ws = new WebSocket('ws://189.58.101.130:43307');
        ws.binaryType = 'arraybuffer';

        const BUFFER_THRESHOLD  = 10;
        const MAX_BUFFER_THRESHOLD = 20;
        
        const channels = [];
        var selectedChannel = null;

        var totalReceivedBytes = 0;
        var isPlaying = false;
        var startTime = 0;

        function mergeBuffer(buffer1, buffer2)
        {
            if ( buffer1 == null )
            {
                let result = new Uint8Array(buffer2.byteLength);
                result.set(new Uint8Array(buffer2), 0);
                return result.buffer;
            }

            if ( buffer2 == null )
            {
                let result = new Uint8Array(buffer1.byteLength);
                result.set(new Uint8Array(buffer1), 0);
                return result.buffer;
            }

            let result = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
            result.set(new Uint8Array(buffer1), 0);
            result.set(new Uint8Array(buffer2), buffer1.byteLength);

            return result.buffer;
        }

        function updateLabels()
        {
            document.getElementById('selectedChannel').innerHTML = '<strong>' + selectedChannel["channel"] + '</strong>';
            document.getElementById('playing').innerHTML = '<strong>' + selectedChannel["playing"] + '</strong>';
            document.getElementById('currentAudioBufferQueue').innerHTML = '<strong>' + selectedChannel["audioQueue"].length + 's</strong>';
            document.getElementById('totalReceivedBytes').innerHTML = '<strong>' + totalReceivedBytes + '</strong>';
            
        }

        function selectChannel( name ) {
            let channel = channels.find( (k) => k.channel === name );
            if ( channel )
            {
                this.selectedChannel = channel;
                updateLabels();
            }
        }
        ws.onmessage = (event) => 
        {

            const message = JSON.parse(event.data);

            if ( message.event === "GUEST_CONNECT" )
            {

            }
            else if ( message.event === "GUEST_DISCONNECT" )
            {

            }
            // If is wave header
            else if ( message.event === "CHANNEL_HEADER" )
            {
                let channel = channels.find( (k) => k.channel === message.channel );
                if ( channel === undefined )
                {
                    channel = {};
                    channel["isBuffered"] = false;
                    channel["audioQueue"] = [];
                    channels.push(channel);
                }

                channel["channel"] = message.channel;
                channel["playing"] = message.playing;
                channel["headerArrayBuffer"] = new Uint8Array(message.data).buffer

                // Set default selected channel
                if ( selectedChannel === null )
                    selectedChannel = channel;
            }
            else if ( message.event === "STREAM" )
            {
                const channel = channels.find( (k) => k.channel === message.channel );
                const arrayBuffer = new Uint8Array(message.data).buffer;
                totalReceivedBytes += arrayBuffer.byteLength;
            
                // Update labels
                updateLabels();

                produce(channel, mergeBuffer(channel["headerArrayBuffer"], arrayBuffer));

                if  ( selectedChannel["audioQueue"].length >= BUFFER_THRESHOLD && !isPlaying )
                {
                    //channel["isBuffered"] = true;
                    playNextBuffer();
                }         
            }
        };

        async function produce(channel, buffer)
        {
            try
            {
                const decodedAudioDataBuffer = await audioContext.decodeAudioData(buffer)
                channel["audioQueue"].push(decodedAudioDataBuffer);

                if ( channel["audioQueue"].length > MAX_BUFFER_THRESHOLD )
                    channel["audioQueue"].shift();
            
            } catch (error) {
                console.error('Error decoding audio data:', error);
                ws.close();
            }
        }

        ws.onopen = () => {
            console.log('Connected to server');
        };

        ws.onclose = () => {
            console.log('Disconnected from server');
        };

        ws.onerror = (error) => {
            console.error('WebSocket Error:', error);
        };

   
        function playNextBuffer()
        {
            if (isPlaying)
            {
                return;
            }
                
            
            if (selectedChannel["audioQueue"].length > 0)
            {

                // Set control var
                isPlaying = true;

                // get buffer from queue
                const decodedAudioDataBuffer = selectedChannel["audioQueue"].shift();
                const source = audioContext.createBufferSource();
                source.buffer = decodedAudioDataBuffer;
                source.connect(audioContext.destination);

                // Start playing
                //console.log("starting at time", startTime);
                startTime += source.buffer.duration;
                source.start(0);
                //console.log('Playing buffer');
                
                // Play next on end
                source.onended = () =>
                {
                    isPlaying = false;
                    playNextBuffer();
                }
            } else {
                console.log("audio buffer is empty");
            }
        }
    </script>

    <div>Channel: <span id="selectedChannel">-</span></div>
    <div>Playing: <span id="playing">-</span></div>
    <div>Current audio buffer (seconds): <span id="currentAudioBufferQueue"></span></div>
    <div>Total received bytes: <span id="totalReceivedBytes"></span></div>
</body>
</html>
